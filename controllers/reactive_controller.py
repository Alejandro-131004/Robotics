# -*- coding: utf-8 -*-
"""controllers/reactive_controller.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WH2G52r3SR9cBywE9ehYIybqSlX13fBB
"""

# controllers/reactive_controller.py
"""
Contém a lógica do controlador reativo clássico (wall-follower)
baseado no script original do utilizador.
"""
import math
import numpy as np

def reactive_controller_logic(dist_values: list) -> tuple[float, float]:
    """
    Lógica de controlo reativo de parede, adaptada do ficheiro original.
    """
    direction: int = 1  # Segue a parede à direita
    maxSpeed: float = 0.1
    distP: float = 10.0
    angleP: float = 7.0
    wallDist: float = 0.1

    size: int = len(dist_values)
    if size == 0:
        return 0.0, 0.0

    # Garante que os valores de distância são números finitos
    dist_values = np.nan_to_num(dist_values, nan=np.inf)

    # Encontra o índice do raio com a distância mínima
    min_index: int = 0
    current_min_dist = float('inf')
    for i in range(size):
        dist = dist_values[i]
        if 0 < dist < current_min_dist:
            current_min_dist = dist
            min_index = i

    angle_increment: float = 2 * math.pi / (size - 1) if size > 1 else 0.0
    angleMin: float = (size / 2 - min_index) * angle_increment
    distMin: float = dist_values[min_index]
    distFront: float = dist_values[size // 2]

    linear_vel: float
    angular_vel: float

    # Lógica de decisão do comportamento do robô
    if math.isfinite(distMin):
        # Controlo regular de parede
        angular_vel = direction * distP * (distMin - wallDist) + angleP * (angleMin - direction * math.pi / 2)

        if distFront < wallDist:
            # Vira se estiver demasiado perto de um obstáculo frontal
            linear_vel = 0
        elif distFront < 2 * wallDist or distMin < wallDist * 0.75 or distMin > wallDist * 1.25:
            # Desacelera se estiver a ajustar a distância à parede
            linear_vel = 0.5 * maxSpeed
        else:
            # Velocidade de cruzeiro
            linear_vel = maxSpeed
    else:
        # Navega aleatoriamente se não detetar paredes
        angular_vel = np.random.normal(loc=0.0, scale=0.5) * maxSpeed
        linear_vel = maxSpeed

    return linear_vel, angular_vel